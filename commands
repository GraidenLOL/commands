	***** ARCHIVE COMMANDS *****
gtar -xvf /gz_file.gz /location ./folder_to_extract
gtar -cp -C /folder .| pigz -9 -p 4 -c - >/file_to_archive.gz

	***** CLEAN VAR FOLDER *****
yum clean all
du -sh /var/run/*
logrotate -v /etc/logrotate.d/syslog

	***** REMOVE FILES FROM DELETED PROCESSES *****
lsof +L1 | grep '(deleted)' | grep tmp
kill PID

	***** TEST CONNECTIVITY COMMANDS *****
curl -v(vv) ip:port
nc -zv ip port
nc -l hostname port (for listening server)
tracepath ip
telnet ip port
	PowerShell - https://kb.netapp.com/app/answers/answer_view/a_id/1029866/~/how-to-test-port-connectivity-without-the-use-of-telnet-
Test-NetConnection -ComputerName ip -Port port -InformationLevel Detailed

	***** TEST INCOMING CONNECTION *****
</dev/tcp/ip:port && echo port OPEN || echo port CLOSED
	***** TEST OUTGOING CONNECTION *****
>/dev/tcp/ip:port && echo port OPEN || echo port CLOSED
or simply echo $0

	***** CREATE AN OPENSSL SERVER *****
openssl s_server -accept port -cert server.crt -key server.key -CAfile ca.crt -verify 2 -verify_return_error -state
	***** CREATE AN OPENSSL SERVER WITH NO OLD TLS *****
openssl s_server -accept port -cert /server.cer -key /server.key -CAfile /etc/pki/tls/cert.pem -verify 2 -no_tls1 -no_ssl3 -no_ssl2 -state -debug

	***** CHECK CONNECTIVITY FROM LINUX *****
openssl s_client -connect ip:port -tls1
openssl s_client -connect ip:port -tls1_2
/bin/openssl s_client -debug -connect ip:port -state -quiet

	***** CHECK SSL CONNECTIVITY *****
openssl s_client -connect ip:port -showcerts -debug -tls1_2
openssl s_client -connect ip:port -showcerts -debug -tls1

	***** SSL CERTIFICATES KNOWLEDGE *****
https://www.sslshopper.com/
https://www.sslshopper.com/article-most-common-openssl-commands.html
https://www.sslshopper.com/ssl-converter.html

	***** REMOVE / MOVE ALL FILES BUT ONE IN CURRENT FOLDER - NO SPACES IN FILE NAME *****
ls | grep -v file.txt | xargs rm -rf
ls | grep -v target_directory | xargs mv -t target_directory
OR
mv !(target_directory) target_directory

	***** LOGROTATE FILES *****
/etc/rsyslog.d/app.conf
vim /etc/rsyslog.d/app.conf
# Save user messages also to user.log
user.*                       -/var/log/user.log

chmod 644 /etc/rsyslog.d/app.conf

	***** ARCHIVE FILES LINUX *****
zip file.zip file1 file2				- zip -r for directories
ls -ltr /folder/ | grep "Feb 19\|Feb 20" | awk '{print $9}' > file_out.txt
zip file.zip -@ < /tmp/file.txt
echo|mail -s "subject" -a file "mail@address.com"

exportÂ GZIP=-9
tar cvzf file.tar.gz /path/to/directory			- for directories

	***** EXTRACT SPECIFIC FOLDER FROM ARCHIVE *****
tar -xvf file.tar ./specific_folder

	***** FIND command *****
find ./ -type f -mtime +30 | xargs ls -l | awk '{SUM += $5} END { print "Total:", SUM/1024/1024/1024, "GBs" }'
find ./ -type f -mtime +30 | xargs du -s | awk '{SUM += $1} END { print "Total:", SUM/1024/1024, "GBs" }'
find ./ -name "*log" -type f -mtime +30 | xargs tar --ignore-failed-read -cvf "monitor-${YEAR}${MONTH}${DAY}-${HOUR}${MIN}${SEC}.tar"
find ./ -name "*log" -type f -mtime +30 | xargs rm -rf

	***** TOP 10 PROCESSES USING SWAP MEMORY *****
	without percent
find /proc -maxdepth 2 -path "/proc/[0-9]*/status" -readable -exec awk -v FS=":" '{process[$1]=$2;sub(/^[ \t]+/,"",process[$1]);} END {if(process["VmSwap"] && process["VmSwap"] != "0 kB") printf "%10s %-30s %20s\n",process["Pid"],process["Name"],process["VmSwap"]}' '{}' \; | awk '{print $(NF-1),$0}' | sort -hr | head | cut -d " " -f2-
	percent
find /proc -maxdepth 2 -path "/proc/[0-9]*/status" -readable -exec awk -v FS=":" -v TOTSWP="$(cat /proc/meminfo | sed  -n -e "s/^SwapTotal:[ ]*\([0-9]*\) kB/\1/p")" '{process[$1]=$2;sub(/^[ \t]+/,"",process[$1]);} END {if(process["VmSwap"] && process["VmSwap"] != "0 kB") {used_swap=process["VmSwap"];sub(/[ a-zA-Z]+/,"",used_swap);percent=(used_swap/TOTSWP*100); printf "%10s %-30s %20s %6.2f%\n",process["Pid"],process["Name"],process["VmSwap"],percent} }' '{}' \;  | awk '{print $(NF-2),$0}' | sort -hr | head | cut -d " " -f2-

	***** READ BINARY FILES *****
od -cx file | less

	***** General OpenSSL Commands *****
	Generate a new private key and Certificate Signing Request
openssl req -out CSR.csr -new -newkey rsa:2048 -nodes -keyout privateKey.key
	Generate a self-signed certificate (see How to Create and Install an Apache Self Signed Certificate for more info)
openssl req -x509 -sha256 -nodes -days 365 -newkey rsa:2048 -keyout privateKey.key -out certificate.crt
	Generate a certificate signing request (CSR) for an existing private key
openssl req -out CSR.csr -key privateKey.key -new
	Generate a certificate signing request based on an existing certificate
openssl x509 -x509toreq -in certificate.crt -out CSR.csr -signkey privateKey.key
	Remove a passphrase from a private key
openssl rsa -in privateKey.key -out newPrivateKey.key
	Extract the public key from the private key
openssl rsa -in private.key -pubout -out public.key

		Checking Using OpenSSL
	Check Certificate Signing Request (CSR)
openssl req -text -noout -verify -in CSR.csr
	Check private key
openssl rsa -in privateKey.key -check
	Check certificate (PEM)
openssl x509 -in certificate.crt -text -noout
	Check certificate (DER)
openssl x509 -in certificate.crt -text -noout -inform DER
	Check a PKCS#12 file (.pfx or .p12)
openssl pkcs12 -info -in keyStore.p12

	Check Certificate and private key match
	https://www.ibm.com/support/pages/how-verify-if-private-key-matches-certificate
openssl x509 -noout -modulus -in certificate.crt | openssl md5
openssl rsa -noout -modulus -in privateKey.txt | openssl md5
	where:
certificate.crt is your certificate
privateKey.txt is your private key

	***** keyStore.p12 & keyStore.jks generation *****
openssl pkcs12 -export -out keyStore.p12 -inkey privateKey.key -in certificate.cer -name name_env (and -certfile /etc/pki/tls/cert.pem if the whole CA chain is needed)
TO BE TESTED: openssl pkcs12 -export -in certificate.cer -inkey privateKey.key -out keyStore.p12 -name name_env -chain

keytool -importkeystore -srckeystore keyStore.p12 -srcstoretype pkcs12 -destkeystore keyStore.jks -deststoretype JKS
	OR
keytool -importkeystore -deststorepass password -destkeypass password -destkeystore keyStore.jks -deststoretype JKS -srckeystore keyStore.p12 -srcstoretype PKCS12 -srcstorepass password -alias name_env

openssl pkcs12 -info -in keyStore.p12
keytool -list -v -keystore keyStore.jks

		Debugging Using OpenSSL - get hash of public Key
openssl x509 -noout -modulus -in certificate.crt | openssl md5
openssl rsa -noout -modulus -in privateKey.key | openssl md5
openssl req -noout -modulus -in CSR.csr | openssl md5

		Converting Using OpenSSL
	Convert a DER file (.crt .cer .der) to PEM
openssl x509 -inform der -in certificate.cer -out certificate.pem
	Convert a PEM file to DER
openssl x509 -outform der -in certificate.pem -out certificate.der
	Convert a PKCS#12 file (.pfx .p12) containing a private key and certificates to PEM
openssl pkcs12 -in keyStore.p12 -nodes -out privateKey_certs.pem
	You can add -nocerts to only output the private key or add -clcerts -nokeys to only output the certificates.
openssl pkcs12 -in keyStore.p12 -nocerts -out privateKey.pem
openssl pkcs12 -in keyStore.p12 -clcerts -nokeys -out publicCert.pem
	TO DEBUG
openssl s_client -connect port:ip -CAfile cert.pem -key privateKey.pem -cert publicCert.pem -state -debug
	Convert a PEM certificate file and a private key to PKCS#12 (.pfx .p12)
openssl pkcs12 -export -out certificate.p12 -inkey privateKey.key -in certificate.crt -certfile CACert.crt
	Convert a PKCS#12 (.pfx .p12) that contains certificate file and a private key to JKS
keytool -importkeystore -deststorepass [changeit] -destkeypass [changeit] -destkeystore server.keystore -srckeystore server.p12 -srcstoretype PKCS12 -srcstorepass some-password -alias [some-alias]

	***** CHECK .CRT FILES - CERTIFICATES *****
Certificate expiration date check - execute commands on it to see the certificate info
openssl x509 -in certificate.crt -text -noout
openssl x509 -in certificate.pem -noout -text
keytool -printcert -file certificate.crt -v

OR
openssl x509 -enddate -noout -in certificate.crt
openssl x509 -enddate -noout -in certificate.pem
openssl x509 -checkend 0 -in certificate.crt
openssl x509 -checkend 220752000 -in /etc/pki/tls/certificate.pem (expiration check for 7 years in seconds)
openssl verify -CAfile certificate.pem certificate.cer

CER is an X.509 certificate in binary form, DER encoded.
CRT is a binary X.509 certificate, encapsulated in text (base-64) encoding.
openssl x509 -inform DER -in certificate.cer -out certificate.crt
openssl x509 -inform PEM -in certificate.cer -out certificate.crt
file certificate.cer certificate.crt

keyStore.p12 & keyStore.jks generation
/usr/bin/openssl pkcs12 -export -out keyStore.p12 -inkey privateKey.key -in certificate.crt/certificate.cer -certfile ca.crt
/usr/bin/keytool -importkeystore -srckeystore keyStore.p12 -srcstoretype pkcs12 -destkeystore keyStore.jks -deststoretype jks

certificate.pem generation
openssl pkcs12 -in keyStore.p12 -out certificate.pem

	***** Technical details for SSL mutual TLS connection *****
https://blogs.msdn.microsoft.com/kaushal/2015/05/27/client-certificate-authentication-part-1/ 
https://tools.ietf.org/html/rfc5246#section-7.4.4 

	***** when there is new SSL session every thing begins with handshake, a part of it is:
1.) client generates some random key and sends it to server
2.) server encrypts by RSA the key and sends it back to client
3.) client decrypts the encrypted key and if it has same value as the original value, it means he can trust server
 
private key is for encryption
public key is for decryption
 
in mutual SSL authentication, which is extension of the process above, everything repeats also opposite way:
1.) server generates some random key and sends it to client
2.) client encrypts by RSA the key and sends it back to server
3.) server decrypts the encrypted key and if it has same value as the original value, it means he can trust client 
 
therefore both sides must have: 
A side: private_key_A+public_key_B 
B side: public_key_A+private_key_B

	***** CHECK OPEN PORTS && CONNECTIONS *****
for i in {1..2000}; do </dev/tcp/0.0.0.0/${i} && echo ${i} is OPEN; done 2>/dev/null
for i in {15000..15500}; do </dev/tcp/0.0.0.0/${i} && echo ${i} is OPEN; done 2>/dev/null
netstat -tpln | grep :18

netstat -an | grep port| cut -c45-63|awk -F':' '{print $1}'|sort| uniq -c

	***** KILL AFK/ZOMBIE SESSIONS *****
who > see users
ps -ef | grep pts/x		> kill -9 afk sessions

	***** PERMISSIONS FOR FOLDERS AND FILES IN /FOLDER *****
permissions in $FOLDER and its subfolders
find ./ -type d -exec chown user.group {} \;
find ./ -type d -exec chmod 2770 {} \;
find ./ -type f -exec chown user.group {} \;
find ./ -type f -exec chmod 640 {} \;

	***** USER CREATION *****
service sssd stop
useradd -g main_group -G group2,group3 -s /bin/ksh user
useradd -g main_group -G group2,group3 -s /bin/ksh user
usermod -a -G group4 user					#append existing group to user
usermod -G wheel,group2,group3 user
gpasswd -a user group					#add user to group
gpasswd -d user group					#delete user from group
service sssd start

	***** PASSWORD EXPIRATION DATE *****
chage -l user				>info about user
chage -d 2019-09-24 user		>date + max no of days to expire

	***** FIX SLOW LOGGING IN *****
vim /etc/ssh/sshd_config > USE DNS no
service sshd restart
vim /etc/hosts > ip + name of server
netstat -plnt

	***** FIND PASSWORD HASH *****
echo -n password | md5sum				hash of password string with md5 encryption
echo -n password | sha256sum				hash of password string with sha256 encryption

	***** FIND TEXT IN FILES *****
grep -rnw 'path' -e 'text'
find ./ -type f | xargs grep "text"

	***** OPERATING WITH DIRECTORIES *****
Removing old directories:

find /path/to/base/dir/* -type d -ctime +10 -exec rm -rf {} \;

	find: the unix command for finding files / directories / links etc.
	/path/to/base/dir: the directory to start your search in.
	-type d: only find directories
	-ctime +10: only consider the ones with modification time older than 10 days
	-exec ... \;: for each such result found, do the following command in ...
	rm -rf {}: recursively force remove the directory; the {} part is where the find result gets substituted into from the previous part.

		@@@ VI @@@
:%s/.$//					> replace ^M from DOS

		@@@ MISC @@@
1.) sudo vi
2.) :!bash
3.) and you can do whatever you need

	***** Files newer (modified by time -mt) than first date, not older than last date *****
find ./ -name "*text*" -type f -newermt "2021-11-22 00:00:00" \! -newermt "2021-11-23 04:19:00" | xargs ls -ltr
find ./ -name "*text*" -type f -newermt "2020-06-15 00:00:00" \! -newermt "2020-06-16 04:25:00" | xargs du -s | awk '{SUM += $1} END { print "Total:", SUM/1024/1024, "GBs" }'
find ./ -type f -newermt "2019-04-18 11:25:00" \! -newermt "2019-04-18 21:00:00"
find ./ -type f -newermt "2019-11-28 08:00:00" \! -newermt "2019-11-29 08:00:00" | xargs ls -ltr | grep -v sem | grep -v XFB | less

	***** SET PASSWORD FOR USER LIST *****
for i in $(awk '{print $NF}' user.list); do id $i; done
for i in $(awk '{print $NF}' user.list); do echo "password" | passwd $i --stdin; done

	***** MODIFY USERS IN USER LIST *****
awk -F'[=()]' '{print $3}' user.list
for i in $(awk -F'[=()]' '{print $3}' user.list); do grep $i /etc/passwd; done
for i in $(awk -F'[=()]' '{print $3}' user.list); do usermod -s /sbin/nologin $i; done
for i in $(awk -F'[=()]' '{print $3}' user.list); do grep $i /etc/passwd; done

	Find connections on port
cat /log | awk -F'[:;]' '$1~/^Start_string1/{dt=$2;tm=$4;tm2=$5;tm3=$6} $1~/^Start_string2/&&$4~/^port$/{print dt,tm":"tm2":"tm3,$0}' |head -30
	ProfileSVStats RespTime max > 2s
awk -F'[;:]' '$1~/^Start_string1/{dt=$2;tm=$4;tm2=$5;tm3=$6} $1~/^Start_string2/&&$2~/^Start_string3/{if($24 > 2) print dt,tm":"tm2":"tm3,$0}' log | less
	With sorting
awk -F'[;:]' '$1~/^Start_string1/{dt=$2;tm=$4;tm2=$5;tm3=$6} $1~/^Start_string2/&&$2~/^Start_string3/{if($24 > 2) print dt,tm":"tm2":"tm3,$0" "$24}' log | sort -nr -k 4

find . -name "file" | xargs grep "string" | awk '{print $1}' | awk -F':' '{print $2 "\t" $3}' | sort -u

replace first x lines from a file
sed -i.bak '1,xd' file*

replace from line x to line y from a file
sed -i.bak 'x,yd' file

replace last x lines from a file
sed -i -e :a -e '$d;N;2,xba' -e 'P;D' file

find in file between timestamps
sed -rne '/09:20:50/,/09:21:40/ p' file

sudo vi
:!bash
commands

netsh wlan show profile name="Wifi" key=clear
